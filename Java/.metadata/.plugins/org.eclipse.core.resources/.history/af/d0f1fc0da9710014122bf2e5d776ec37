package openGL.wrappers.implementations;

import static openGL.OpenGLHelper.openGLErrorCheck;
import static org.lwjgl.opengl.GL11.*;
import static org.lwjgl.opengl.GL30.*;

import java.util.AbstractCollection;

import openGL.exceptions.OpenGLInvalidFramebufferOperationException;
import openGL.wrappers.interfaces.FramebufferAttachment;
import openGL.wrappers.interfaces.FramebufferObject;

public class OpenGLFramebufferObject extends OpenGLFramebuffer implements FramebufferObject
{
	private int fboId;
	private AbstractCollection<FramebufferAttachment> attachments;
	
	public OpenGLFramebufferObject(int colorAttachments, boolean depthAttachment, boolean stencilAttachment, boolean combineDepthAndStencil)
	{
		this.fboId = glGenFramebuffers();
		openGLErrorCheck();
		
		if (colorAttachments <= 0)
		{
			throw new IllegalArgumentException("Number of color attachments must be a positive number.");
		}
		
		if (colorAttachments > GL_MAX_COLOR_ATTACHMENTS)
		{
			throw new IllegalArgumentException("Too many color attachments specified - maximum is " + GL_MAX_COLOR_ATTACHMENTS + ".");
		}
		
		for (int i = 0; i < colorAttachments; i++)
		{
			FramebufferAttachment attachment = new OpenGLRenderbuffer();
			this.bindForDraw();
			attachment.bindToDrawFramebuffer(GL_COLOR_ATTACHMENT0 + i, 0);
			attachments.add(attachment);
		}
		
		if (depthAttachment && stencilAttachment && combineDepthAndStencil)
		{
			FramebufferAttachment attachment = new OpenGLRenderbuffer();
			this.bindForDraw();
			attachment.bindToDrawFramebuffer(GL_DEPTH_STENCIL_ATTACHMENT, 0);
			attachments.add(attachment);
		}
		else
		{
			if (depthAttachment)
			{
				FramebufferAttachment attachment = new OpenGLRenderbuffer();
				this.bindForDraw();
				attachment.bindToDrawFramebuffer(GL_DEPTH_ATTACHMENT, 0);
				attachments.add(attachment);
			}
			
			if (stencilAttachment)
			{
				FramebufferAttachment attachment = new OpenGLRenderbuffer();
				this.bindForDraw();
				attachment.bindToDrawFramebuffer(GL_STENCIL_ATTACHMENT, 0);
				attachments.add(attachment);
			}
		}
		
		if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
		{
			throw new OpenGLInvalidFramebufferOperationException();
		}
		openGLErrorCheck();
	}
	
	@Override
	protected int getId()
	{
		return fboId;
	}

	@Override
	protected void selectColorSourceForRead(int index) 
	{
		glReadBuffer(GL_COLOR_ATTACHMENT0 + index);
		openGLErrorCheck();
	}
	
	@Override
	public void delete()
	{
		glDeleteFramebuffers(this.fboId);
		openGLErrorCheck();
		for (FramebufferAttachment attachment : attachments)
		{
			attachment.delete();
		}
	}
}
